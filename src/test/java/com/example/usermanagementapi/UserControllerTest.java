package com.example.usermanagementapi;

import com.example.usermanagementapi.model.User;
import com.example.usermanagementapi.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.assertj.core.api.Assertions.assertThat; // Import AssertJ for fluent assertions

@SpringBootTest // Loads the full Spring application context for integration testing
@AutoConfigureMockMvc // Configures MockMvc for testing MVC controllers
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc; // Injects MockMvc, which allows us to perform HTTP requests

    @Autowired
    private ObjectMapper objectMapper; // Used to convert Java objects to JSON and vice-versa

    // We autowire the real repository here. For faster, more isolated unit-like tests
    // of the controller, one might use @MockBean UserRepository userRepository;
    // and then define mock behaviors. For full integration testing of the web layer
    // with the data layer, using the real repository is appropriate, typically with
    // an in-memory database like H2 or Testcontainers.
    @Autowired
    private UserRepository userRepository;

    // These will hold the User objects that are persisted in the @BeforeEach method.
    // Their IDs will be set by the database.
    private User user1;
    private User user2;
    private List<User> manyUsers; // For pagination tests

    /**
     * @BeforeEach: This method runs before each test method.
     * It ensures a clean state for each test by deleting all existing users
     * and then populating the database with a consistent set of initial users.
     * It also registers the JavaTimeModule for ObjectMapper to handle LocalDateTime.
     */
    @BeforeEach
    void setUp() {
        userRepository.deleteAll(); // Clear the repository before each test to ensure test isolation
        objectMapper.registerModule(new JavaTimeModule()); // Crucial for handling LocalDateTime in JSON

        // Create initial User objects without manually setting IDs.
        // The database will generate them upon saving.
        User initialUser1 = new User("John Doe", "john.doe@example.com");
        User initialUser2 = new User("Jane Smith", "jane.smith@example.com");

        // Save the users and capture the returned managed entities.
        // These entities will have the IDs generated by the database,
        // which we then assign to our test class fields (user1, user2).
        List<User> savedInitialUsers = userRepository.saveAll(Arrays.asList(initialUser1, initialUser2));
        this.user1 = savedInitialUsers.get(0);
        this.user2 = savedInitialUsers.get(1);

        // Create many additional users for pagination tests.
        // These also have their IDs generated by the database.
        manyUsers = IntStream.rangeClosed(1, 25)
                .mapToObj(i -> new User("User " + i, "user" + i + "@example.com"))
                .collect(Collectors.toList());
        userRepository.saveAll(manyUsers);
    }

    /**
     * Tests the POST /api/users endpoint for creating multiple users.
     * Verifies HTTP status, response JSON structure, and persistence in the database.
     */
    @Test
    void testCreateUsers() throws Exception {
        // Create new users to be sent in the POST request.
        // Their IDs are null at this point, as they will be generated by the database.
        User newUser1 = new User("Alice Brown", "alice.brown@example.com");
        User newUser2 = new User("Bob White", "bob.white@example.com");
        List<User> newUsers = Arrays.asList(newUser1, newUser2);

        // Perform the POST request using MockMvc.
        mockMvc.perform(post("/api/users") // Build a POST request to the /api/users endpoint
                        .contentType(MediaType.APPLICATION_JSON) // Set the Content-Type header to application/json
                        .content(objectMapper.writeValueAsString(newUsers))) // Convert the list of users to a JSON string for the request body
                .andExpect(status().isCreated()) // Assert that the HTTP status is 201 Created
                .andExpect(jsonPath("$", hasSize(2))) // Assert that the root of the JSON response is an array of size 2
                .andExpect(jsonPath("$[0].name", is("Alice Brown"))) // Assert the name of the first user in the response
                .andExpect(jsonPath("$[0].email", is("alice.brown@example.com"))) // Assert the email of the first user
                .andExpect(jsonPath("$[0].id", notNullValue())) // Assert that the first user's ID is not null (meaning it was assigned by DB)
                .andExpect(jsonPath("$[1].name", is("Bob White"))) // Assert the name of the second user
                .andExpect(jsonPath("$[1].email", is("bob.white@example.com"))) // Assert the email of the second user
                .andExpect(jsonPath("$[1].id", notNullValue())); // Assert that the second user's ID is not null

        // Verify that the total number of users in the database has increased by 2.
        // We use userRepository.count() to get the current count after the operation.
        assertThat(userRepository.count()).isEqualTo(2 + 2 + 25); // Initial 2 + 2 new users + 25 manyUsers
    }

    /**
     * Tests the GET /api/users/{id} endpoint when a user is found.
     * Verifies HTTP status and the content of the retrieved user.
     */
    @Test
    void testGetUserByIdFound() throws Exception {
        mockMvc.perform(get("/api/users/{id}", user1.getId()) // Perform GET request using the dynamically assigned ID of user1
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk()) // Assert HTTP 200 OK status
                .andExpect(jsonPath("$.id", is(user1.getId().intValue()))) // Assert the ID in the response JSON
                .andExpect(jsonPath("$.name", is(user1.getName()))) // Assert the name in the response JSON
                .andExpect(jsonPath("$.email", is(user1.getEmail()))); // Assert the email in the response JSON
    }

    /**
     * Tests the GET /api/users/{id} endpoint when a user is not found.
     * Verifies HTTP status is 404 Not Found.
     */
    @Test
    void testGetUserByIdNotFound() throws Exception {
        mockMvc.perform(get("/api/users/{id}", 999L) // Request a non-existent ID
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound()); // Assert HTTP 404 Not Found status
    }

    /**
     * Tests the PUT /api/users/{id} endpoint for updating an existing user.
     * Verifies HTTP status, updated response JSON, and persistence in the database.
     */
    @Test
    void testUpdateUserFound() throws Exception {
        User updatedDetails = new User("Johnathan Doe", "john.doe.updated@example.com");
        // The ID in 'updatedDetails' is typically ignored by the controller's @RequestBody;
        // the ID from the path variable is used to find the user to update.

        mockMvc.perform(put("/api/users/{id}", user1.getId()) // Perform PUT request using user1's ID
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(updatedDetails))) // Send updated user details as JSON
                .andExpect(status().isOk()) // Assert HTTP 200 OK
                .andExpect(jsonPath("$.id", is(user1.getId().intValue()))) // Assert ID remains the same
                .andExpect(jsonPath("$.name", is("Johnathan Doe"))) // Assert name is updated
                .andExpect(jsonPath("$.email", is("john.doe.updated@example.com"))); // Assert email is updated

        // Verify that the user was actually updated in the database
        Optional<User> retrievedUser = userRepository.findById(user1.getId());
        assertThat(retrievedUser).isPresent(); // Assert user is still present
        assertThat(retrievedUser.get().getName()).isEqualTo("Johnathan Doe"); // Assert updated name
        assertThat(retrievedUser.get().getEmail()).isEqualTo("john.doe.updated@example.com"); // Assert updated email
        // Note: Checking updatedAt.isAfter(originalUpdatedAt) can be flaky due to timing.
        // It's often sufficient to just check the updated fields.
    }

    /**
     * Tests the PUT /api/users/{id} endpoint when attempting to update a non-existent user.
     * Verifies HTTP status is 404 Not Found.
     */
    @Test
    void testUpdateUserNotFound() throws Exception {
        User updatedDetails = new User("Non Existent", "non.existent@example.com");

        mockMvc.perform(put("/api/users/{id}", 999L) // Attempt to update a non-existent ID
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(updatedDetails)))
                .andExpect(status().isNotFound()); // Assert HTTP 404 Not Found
    }

    /**
     * Tests the DELETE /api/users/{id} endpoint for deleting an existing user.
     * Verifies HTTP status and that the user is removed from the database.
     */
    @Test
    void testDeleteUserFound() throws Exception {
        mockMvc.perform(delete("/api/users/{id}", user1.getId())) // Perform DELETE request using user1's ID
                .andExpect(status().isNoContent()); // Assert HTTP 204 No Content

        // Verify that the user is no longer in the database
        Optional<User> deletedUser = userRepository.findById(user1.getId());
        assertThat(deletedUser).isNotPresent(); // Assert that the user is not found
    }

    /**
     * Tests the DELETE /api/users/{id} endpoint when attempting to delete a non-existent user.
     * Verifies HTTP status is 404 Not Found.
     */
    @Test
    void testDeleteUserNotFound() throws Exception {
        mockMvc.perform(delete("/api/users/{id}", 999L)) // Attempt to delete a non-existent ID
                .andExpect(status().isNotFound()); // Assert HTTP 404 Not Found
    }

    /**
     * Tests the GET /api/users endpoint with pagination and sorting.
     * Verifies default pagination, custom pagination, and sorting by name.
     */
    @Test
    void testGetUsersPaginationAndSorting() throws Exception {
        // Test default pagination (page 0, size 20)
        mockMvc.perform(get("/api/users/page")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(20))) // Expect 20 users on the first page
                .andExpect(jsonPath("$.totalElements", is((int) userRepository.count()))) // Total elements in the DB
                .andExpect(jsonPath("$.totalPages", is((int) Math.ceil((double) userRepository.count() / 20)))) // Calculate total pages based on actual count
                .andExpect(jsonPath("$.number", is(0))); // Current page is 0

        // Test custom pagination (page 1, size 10)
        mockMvc.perform(get("/api/users/page")
                        .param("page", "1") // Request page 1
                        .param("size", "10") // Request size 10
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize(10))) // Expect 10 users on the second page
                .andExpect(jsonPath("$.totalElements", is((int) userRepository.count())))
                .andExpect(jsonPath("$.totalPages", is((int) Math.ceil((double) userRepository.count() / 10))))
                .andExpect(jsonPath("$.number", is(1))); // Current page is 1

        // Test sorting by name ascending
        mockMvc.perform(get("/api/users/page")
                        .param("sort", "name,asc") // Sort by name ascending
                        .param("size", String.valueOf(userRepository.count())) // Get all users to check sorting
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.content", hasSize((int) userRepository.count())))
                // Fetch all users from DB and sort them in memory to get the expected order for assertion
                .andExpect(jsonPath("$.content[0].name", is(userRepository.findAll().stream()
                        .sorted((u1, u2) -> u1.getName().compareTo(u2.getName()))
                        .collect(Collectors.toList()).get(0).getName())))
                .andExpect(jsonPath("$.content[1].name", is(userRepository.findAll().stream()
                        .sorted((u1, u2) -> u1.getName().compareTo(u2.getName()))
                        .collect(Collectors.toList()).get(1).getName())))
                .andExpect(jsonPath("$.content[2].name", is(userRepository.findAll().stream()
                        .sorted((u1, u2) -> u1.getName().compareTo(u2.getName()))
                        .collect(Collectors.toList()).get(2).getName())));
    }

    /**
     * Tests the validation handling for POST /api/users endpoint with invalid user data.
     * Verifies HTTP status 400 Bad Request and specific error messages in the response.
     */

//    @Test // Coding exercise for students on testing
//    void testCreateUserValidationErrors() throws Exception {
//        // User with invalid name (too short) and invalid email format
//
//    }

    /**
     * Tests the validation handling for PUT /api/users/{id} endpoint with invalid user data.
     * Verifies HTTP status 400 Bad Request and specific error messages in the response.
     */
    @Test
    void testUpdateUserValidationErrors() throws Exception {
        User invalidUpdateDetails = new User("B", "bad@"); // Invalid name (too short) and invalid email format

        mockMvc.perform(put("/api/users/{id}", user1.getId()) // Use user1's ID for the update
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidUpdateDetails)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.name", is("Name must be between 2 and 100 characters")))
                .andExpect(jsonPath("$.email", is("Email should be valid")));
    }
}
